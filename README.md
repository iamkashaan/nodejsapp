
![Github Actions](https://github.com/user-attachments/assets/0a3260a7-dd05-433a-a789-58ca446693b5)
<h1>Automated CI/CD Pipeline for a Node.js App using GitHub Actions ,Kubernetes and ArgoCD</h1>
Part 1: Continuous Integration (CI) - Building & Testing Source Code Commit: The process begins when a developer commits new code or modifies code to a source repository, hosted on a remote repository branch such as GitHub.
GitHub Actions Trigger: This push automatically triggers a predetermined workflow in GitHub Actions. GitHub Actions is being used as the Continuous Integration (CI) server.
Task Install Dependencies : The first task in the process is npminstall. This will install all the project dependencies for a Node. js application.
Test: Once dependencies are installed, an automated test suite can be run in order to test for regression and make sure that the changes didn't break the existing functionality. The diagram then has a tree that contains the option "Yes", i.e. the pipeline goes on in the case that all tests succeed. Pipeline Abort on test failure If tests fail, abort the pipeline
Build and Push Docker Image: You're in, the tests are green, and the workflow logs in to a container registry (in this case, Docker Hub).It then creates a new Docker image based on the source code. This image contains the application and all of its dependencies in an immutable container.This new image is then "pushed" (uploaded) to Docker Hub, and tagged with a unique identifier (such as a version number or commit hash).
Part 2: Continuous Deployment (CD) / Deploying with GitOps In this part of the pipeline we use a GitOps approach where we use a Git repository as the only source of truth for the intended state of the application. The tool that implements this is ArgoCD.
Image Updater: A process (depicted here as “Image updater”—for example, ArgoCD Image Updater, or other such mechanism) is always monitoring Docker Hub for new images of our application.
Update Manifest Repo: After the Image Updater has noticed the new image that has just been pushed, it then makes a commit to a different Git repository, the "Manifest repo". This Markdown file describes a simple application that can be deployed to Kubernetes, and demonstrates the kinds of configuration elements you might create in a parameterized plan. This repository contains the Kubernetes configuration files (Kubernetes manifests) that defines how the application should be deployed by Kubernetes. It updates the deployment manifest with the new version of the image by touching the image tag.
ArgoCD Catches Change: ArgoCD is set up to “live watch” the “Manifest repo”. The commit that the Image Updater made is detected and the state that we defined in Git no longer matches
Sync and Deploy: ArgoCD takes the desired state (from Git repo) and reconciles it against the actual state of app that is running in the kubernetes cluster.Realizing they're out of whack, ArgoCD rips the fresh manifest down from the repo and the new Docker image from the hub.Then it puts the latest config to the kubernetes cluster, causing a rolling deployment, where the new version of the application is going to come with no downtime.
